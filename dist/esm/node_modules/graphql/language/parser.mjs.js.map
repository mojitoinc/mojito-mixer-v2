{"version":3,"file":"parser.mjs.js","sources":["../../../../../node_modules/graphql/language/parser.mjs"],"sourcesContent":["import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options = {}) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const { maxTokens } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(\n          this._lexer.source,\n          token.start,\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n"],"names":[],"mappings":"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"}