'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var bignumber = require('../../../bignumber/lib.esm/bignumber.js');
require('../../../bignumber/lib.esm/fixednumber.js');
var bignumbers = require('../../../constants/lib.esm/bignumbers.js');
var abstractCoder = require('./abstract-coder.js');

class NumberCoder extends abstractCoder.Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = bignumber.BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = bignumbers.MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(bignumbers.One).mul(bignumbers.NegativeOne))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(bignumbers.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}

exports.NumberCoder = NumberCoder;
//# sourceMappingURL=number.js.map
