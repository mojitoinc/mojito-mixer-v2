{"version":3,"file":"fragments.js","sources":["../../../../../../node_modules/@ethersproject/abi/lib.esm/fragments.js"],"sourcesContent":["\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nlet ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        defineReadOnly(object, key, params[key]);\n    }\n}\nexport const FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nexport class Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nexport class EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nexport class ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nexport class FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\nexport class ErrorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n        };\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n    static fromString(value) {\n        let params = { type: \"error\" };\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n    static isErrorFragment(value) {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n//# sourceMappingURL=fragments.js.map"],"names":["Logger","version","defineReadOnly","BigNumber"],"mappings":"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"}