'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index$2 = require('../../bytes/lib.esm/index.js');
var index$1 = require('../../properties/lib.esm/index.js');
var index = require('../../logger/lib.esm/index.js');
var _version = require('./_version.js');
var abstractCoder = require('./coders/abstract-coder.js');
var address = require('./coders/address.js');
var array = require('./coders/array.js');
var boolean = require('./coders/boolean.js');
var bytes = require('./coders/bytes.js');
var fixedBytes = require('./coders/fixed-bytes.js');
var _null = require('./coders/null.js');
var number = require('./coders/number.js');
var string = require('./coders/string.js');
var tuple = require('./coders/tuple.js');
var fragments = require('./fragments.js');

const logger = new index.Logger(_version.version);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        index$1.defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new address.AddressCoder(param.name);
            case "bool":
                return new boolean.BooleanCoder(param.name);
            case "string":
                return new string.StringCoder(param.name);
            case "bytes":
                return new bytes.BytesCoder(param.name);
            case "array":
                return new array.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new tuple.TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new _null.NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new number.NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger.throwArgumentError("invalid bytes length", "param", param);
            }
            return new fixedBytes.FixedBytesCoder(size, param.name);
        }
        return logger.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new abstractCoder.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new abstractCoder.Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(fragments.ParamType.from(type)));
        const coder = new tuple.TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger.throwError("types/values length mismatch", index.Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(fragments.ParamType.from(type)));
        const coder = (new tuple.TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(fragments.ParamType.from(type)));
        const coder = new tuple.TupleCoder(coders, "_");
        return coder.decode(this._getReader(index$2.arrayify(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

exports.AbiCoder = AbiCoder;
exports.defaultAbiCoder = defaultAbiCoder;
//# sourceMappingURL=abi-coder.js.map
