'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index$2 = require('../../bytes/lib.esm/index.js');
require('../../bignumber/lib.esm/bignumber.js');
require('../../bignumber/lib.esm/fixednumber.js');
var utf8 = require('../../strings/lib.esm/utf8.js');
require('../../strings/lib.esm/idna.js');
var index$1 = require('../../keccak256/lib.esm/index.js');
var index = require('../../logger/lib.esm/index.js');
var _version = require('./_version.js');
var lib = require('./ens-normalize/lib.js');

const logger = new index.Logger(_version.version);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
    if (comp.length === 0) {
        throw new Error("invalid ENS name; empty component");
    }
    return comp;
}
function ensNameSplit(name) {
    const bytes = utf8.toUtf8Bytes(lib.ens_normalize(name));
    const comps = [];
    if (name.length === 0) {
        return comps;
    }
    let last = 0;
    for (let i = 0; i < bytes.length; i++) {
        const d = bytes[i];
        // A separator (i.e. "."); copy this component
        if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
        }
    }
    // There was a stray separator at the end of the name
    if (last >= bytes.length) {
        throw new Error("invalid ENS name; empty component");
    }
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
}
function isValidName(name) {
    try {
        return (ensNameSplit(name).length !== 0);
    }
    catch (error) { }
    return false;
}
function namehash(name) {
    /* istanbul ignore if */
    if (typeof (name) !== "string") {
        logger.throwArgumentError("invalid ENS name; not a string", "name", name);
    }
    let result = Zeros;
    const comps = ensNameSplit(name);
    while (comps.length) {
        result = index$1.keccak256(index$2.concat([result, index$1.keccak256(comps.pop())]));
    }
    return index$2.hexlify(result);
}
function dnsEncode(name) {
    return index$2.hexlify(index$2.concat(ensNameSplit(name).map((comp) => {
        // DNS does not allow components over 63 bytes in length
        if (comp.length > 63) {
            throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        }
        const bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}

exports.dnsEncode = dnsEncode;
exports.isValidName = isValidName;
exports.namehash = namehash;
//# sourceMappingURL=namehash.js.map
