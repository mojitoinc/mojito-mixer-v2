'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var aes = require('aes-js');
var scrypt = require('scrypt-js');
var index$1 = require('../../address/lib.esm/index.js');
var index$4 = require('../../bytes/lib.esm/index.js');
var index$3 = require('../../hdnode/lib.esm/index.js');
var index$5 = require('../../keccak256/lib.esm/index.js');
var pbkdf2$1 = require('../../pbkdf2/lib.esm/pbkdf2.js');
var random = require('../../random/lib.esm/random.js');
var index$6 = require('../../properties/lib.esm/index.js');
var index$2 = require('../../transactions/lib.esm/index.js');
var utils = require('./utils.js');
var index = require('../../logger/lib.esm/index.js');
var _version = require('./_version.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var aes__default = /*#__PURE__*/_interopDefaultLegacy(aes);
var scrypt__default = /*#__PURE__*/_interopDefaultLegacy(scrypt);

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new index.Logger(_version.version);
// Exported Types
function hasMnemonic(value) {
    return (value != null && value.mnemonic && value.mnemonic.phrase);
}
class KeystoreAccount extends index$6.Description {
    isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
    }
}
function _decrypt(data, key, ciphertext) {
    const cipher = utils.searchPath(data, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
        const iv = utils.looseArrayify(utils.searchPath(data, "crypto/cipherparams/iv"));
        const counter = new aes__default["default"].Counter(iv);
        const aesCtr = new aes__default["default"].ModeOfOperation.ctr(key, counter);
        return index$4.arrayify(aesCtr.decrypt(ciphertext));
    }
    return null;
}
function _getAccount(data, key) {
    const ciphertext = utils.looseArrayify(utils.searchPath(data, "crypto/ciphertext"));
    const computedMAC = index$4.hexlify(index$5.keccak256(index$4.concat([key.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== utils.searchPath(data, "crypto/mac").toLowerCase()) {
        throw new Error("invalid password");
    }
    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
    if (!privateKey) {
        logger.throwError("unsupported cipher", index.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "decrypt"
        });
    }
    const mnemonicKey = key.slice(32, 64);
    const address = index$2.computeAddress(privateKey);
    if (data.address) {
        let check = data.address.toLowerCase();
        if (check.substring(0, 2) !== "0x") {
            check = "0x" + check;
        }
        if (index$1.getAddress(check) !== address) {
            throw new Error("address mismatch");
        }
    }
    const account = {
        _isKeystoreAccount: true,
        address: address,
        privateKey: index$4.hexlify(privateKey)
    };
    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
    if (utils.searchPath(data, "x-ethers/version") === "0.1") {
        const mnemonicCiphertext = utils.looseArrayify(utils.searchPath(data, "x-ethers/mnemonicCiphertext"));
        const mnemonicIv = utils.looseArrayify(utils.searchPath(data, "x-ethers/mnemonicCounter"));
        const mnemonicCounter = new aes__default["default"].Counter(mnemonicIv);
        const mnemonicAesCtr = new aes__default["default"].ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        const path = utils.searchPath(data, "x-ethers/path") || index$3.defaultPath;
        const locale = utils.searchPath(data, "x-ethers/locale") || "en";
        const entropy = index$4.arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
        try {
            const mnemonic = index$3.entropyToMnemonic(entropy, locale);
            const node = index$3.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
            account.mnemonic = node.mnemonic;
        }
        catch (error) {
            // If we don't have the locale wordlist installed to
            // read this mnemonic, just bail and don't set the
            // mnemonic
            if (error.code !== index.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
                throw error;
            }
        }
    }
    return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return index$4.arrayify(pbkdf2$1.pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = utils.getPassword(password);
    const kdf = utils.searchPath(data, "crypto/kdf");
    if (kdf && typeof (kdf) === "string") {
        const throwError = function (name, value) {
            return logger.throwArgumentError("invalid key-derivation function parameters", name, value);
        };
        if (kdf.toLowerCase() === "scrypt") {
            const salt = utils.looseArrayify(utils.searchPath(data, "crypto/kdfparams/salt"));
            const N = parseInt(utils.searchPath(data, "crypto/kdfparams/n"));
            const r = parseInt(utils.searchPath(data, "crypto/kdfparams/r"));
            const p = parseInt(utils.searchPath(data, "crypto/kdfparams/p"));
            // Check for all required parameters
            if (!N || !r || !p) {
                throwError("kdf", kdf);
            }
            // Make sure N is a power of 2
            if ((N & (N - 1)) !== 0) {
                throwError("N", N);
            }
            const dkLen = parseInt(utils.searchPath(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
        }
        else if (kdf.toLowerCase() === "pbkdf2") {
            const salt = utils.looseArrayify(utils.searchPath(data, "crypto/kdfparams/salt"));
            let prfFunc = null;
            const prf = utils.searchPath(data, "crypto/kdfparams/prf");
            if (prf === "hmac-sha256") {
                prfFunc = "sha256";
            }
            else if (prf === "hmac-sha512") {
                prfFunc = "sha512";
            }
            else {
                throwError("prf", prf);
            }
            const count = parseInt(utils.searchPath(data, "crypto/kdfparams/c"));
            const dkLen = parseInt(utils.searchPath(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
    }
    return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
    const data = JSON.parse(json);
    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt__default["default"].syncScrypt);
    return _getAccount(data, key);
}
function decrypt(json, password, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = JSON.parse(json);
        const key = yield _computeKdfKey(data, password, pbkdf2, scrypt__default["default"].scrypt, progressCallback);
        return _getAccount(data, key);
    });
}
function encrypt(account, password, options, progressCallback) {
    try {
        // Check the address matches the private key
        if (index$1.getAddress(account.address) !== index$2.computeAddress(account.privateKey)) {
            throw new Error("address/privateKey mismatch");
        }
        // Check the mnemonic (if any) matches the private key
        if (hasMnemonic(account)) {
            const mnemonic = account.mnemonic;
            const node = index$3.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || index$3.defaultPath);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
        }
    }
    catch (e) {
        return Promise.reject(e);
    }
    // The options are optional, so adjust the call as needed
    if (typeof (options) === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
    }
    if (!options) {
        options = {};
    }
    const privateKey = index$4.arrayify(account.privateKey);
    const passwordBytes = utils.getPassword(password);
    let entropy = null;
    let path = null;
    let locale = null;
    if (hasMnemonic(account)) {
        const srcMnemonic = account.mnemonic;
        entropy = index$4.arrayify(index$3.mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
        path = srcMnemonic.path || index$3.defaultPath;
        locale = srcMnemonic.locale || "en";
    }
    let client = options.client;
    if (!client) {
        client = "ethers.js";
    }
    // Check/generate the salt
    let salt = null;
    if (options.salt) {
        salt = index$4.arrayify(options.salt);
    }
    else {
        salt = random.randomBytes(32);
    }
    // Override initialization vector
    let iv = null;
    if (options.iv) {
        iv = index$4.arrayify(options.iv);
        if (iv.length !== 16) {
            throw new Error("invalid iv");
        }
    }
    else {
        iv = random.randomBytes(16);
    }
    // Override the uuid
    let uuidRandom = null;
    if (options.uuid) {
        uuidRandom = index$4.arrayify(options.uuid);
        if (uuidRandom.length !== 16) {
            throw new Error("invalid uuid");
        }
    }
    else {
        uuidRandom = random.randomBytes(16);
    }
    // Override the scrypt password-based key derivation function parameters
    let N = (1 << 17), r = 8, p = 1;
    if (options.scrypt) {
        if (options.scrypt.N) {
            N = options.scrypt.N;
        }
        if (options.scrypt.r) {
            r = options.scrypt.r;
        }
        if (options.scrypt.p) {
            p = options.scrypt.p;
        }
    }
    // We take 64 bytes:
    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
    return scrypt__default["default"].scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {
        key = index$4.arrayify(key);
        // This will be used to encrypt the wallet (as per Web3 secret storage)
        const derivedKey = key.slice(0, 16);
        const macPrefix = key.slice(16, 32);
        // This will be used to encrypt the mnemonic phrase (if any)
        const mnemonicKey = key.slice(32, 64);
        // Encrypt the private key
        const counter = new aes__default["default"].Counter(iv);
        const aesCtr = new aes__default["default"].ModeOfOperation.ctr(derivedKey, counter);
        const ciphertext = index$4.arrayify(aesCtr.encrypt(privateKey));
        // Compute the message authentication code, used to check the password
        const mac = index$5.keccak256(index$4.concat([macPrefix, ciphertext]));
        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
        const data = {
            address: account.address.substring(2).toLowerCase(),
            id: utils.uuidV4(uuidRandom),
            version: 3,
            crypto: {
                cipher: "aes-128-ctr",
                cipherparams: {
                    iv: index$4.hexlify(iv).substring(2),
                },
                ciphertext: index$4.hexlify(ciphertext).substring(2),
                kdf: "scrypt",
                kdfparams: {
                    salt: index$4.hexlify(salt).substring(2),
                    n: N,
                    dklen: 32,
                    p: p,
                    r: r
                },
                mac: mac.substring(2)
            }
        };
        // If we have a mnemonic, encrypt it into the JSON wallet
        if (entropy) {
            const mnemonicIv = random.randomBytes(16);
            const mnemonicCounter = new aes__default["default"].Counter(mnemonicIv);
            const mnemonicAesCtr = new aes__default["default"].ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
            const mnemonicCiphertext = index$4.arrayify(mnemonicAesCtr.encrypt(entropy));
            const now = new Date();
            const timestamp = (now.getUTCFullYear() + "-" +
                utils.zpad(now.getUTCMonth() + 1, 2) + "-" +
                utils.zpad(now.getUTCDate(), 2) + "T" +
                utils.zpad(now.getUTCHours(), 2) + "-" +
                utils.zpad(now.getUTCMinutes(), 2) + "-" +
                utils.zpad(now.getUTCSeconds(), 2) + ".0Z");
            data["x-ethers"] = {
                client: client,
                gethFilename: ("UTC--" + timestamp + "--" + data.address),
                mnemonicCounter: index$4.hexlify(mnemonicIv).substring(2),
                mnemonicCiphertext: index$4.hexlify(mnemonicCiphertext).substring(2),
                path: path,
                locale: locale,
                version: "0.1"
            };
        }
        return JSON.stringify(data);
    });
}

exports.KeystoreAccount = KeystoreAccount;
exports.decrypt = decrypt;
exports.decryptSync = decryptSync;
exports.encrypt = encrypt;
//# sourceMappingURL=keystore.js.map
