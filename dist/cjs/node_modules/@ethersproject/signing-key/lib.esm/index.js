'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var elliptic = require('./elliptic.js');
var index$1 = require('../../bytes/lib.esm/index.js');
var index$2 = require('../../properties/lib.esm/index.js');
var index = require('../../logger/lib.esm/index.js');
var _version = require('./_version.js');

const logger = new index.Logger(_version.version);
let _curve = null;
function getCurve() {
    if (!_curve) {
        _curve = new elliptic.EC("secp256k1");
    }
    return _curve;
}
class SigningKey {
    constructor(privateKey) {
        index$2.defineReadOnly(this, "curve", "secp256k1");
        index$2.defineReadOnly(this, "privateKey", index$1.hexlify(privateKey));
        if (index$1.hexDataLength(this.privateKey) !== 32) {
            logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        const keyPair = getCurve().keyFromPrivate(index$1.arrayify(this.privateKey));
        index$2.defineReadOnly(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        index$2.defineReadOnly(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        index$2.defineReadOnly(this, "_isSigningKey", true);
    }
    _addPoint(other) {
        const p0 = getCurve().keyFromPublic(index$1.arrayify(this.publicKey));
        const p1 = getCurve().keyFromPublic(index$1.arrayify(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest) {
        const keyPair = getCurve().keyFromPrivate(index$1.arrayify(this.privateKey));
        const digestBytes = index$1.arrayify(digest);
        if (digestBytes.length !== 32) {
            logger.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature = keyPair.sign(digestBytes, { canonical: true });
        return index$1.splitSignature({
            recoveryParam: signature.recoveryParam,
            r: index$1.hexZeroPad("0x" + signature.r.toString(16), 32),
            s: index$1.hexZeroPad("0x" + signature.s.toString(16), 32),
        });
    }
    computeSharedSecret(otherKey) {
        const keyPair = getCurve().keyFromPrivate(index$1.arrayify(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic(index$1.arrayify(computePublicKey(otherKey)));
        return index$1.hexZeroPad("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
        return !!(value && value._isSigningKey);
    }
}
function recoverPublicKey(digest, signature) {
    const sig = index$1.splitSignature(signature);
    const rs = { r: index$1.arrayify(sig.r), s: index$1.arrayify(sig.s) };
    return "0x" + getCurve().recoverPubKey(index$1.arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
    const bytes = index$1.arrayify(key);
    if (bytes.length === 32) {
        const signingKey = new SigningKey(bytes);
        if (compressed) {
            return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }
        return signingKey.publicKey;
    }
    else if (bytes.length === 33) {
        if (compressed) {
            return index$1.hexlify(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    }
    else if (bytes.length === 65) {
        if (!compressed) {
            return index$1.hexlify(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

exports.SigningKey = SigningKey;
exports.computePublicKey = computePublicKey;
exports.recoverPublicKey = recoverPublicKey;
//# sourceMappingURL=index.js.map
