'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('../../../@babel/runtime/helpers/esm/extends.js');
var objectWithoutPropertiesLoose = require('../../../@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js');
var React = require('react');
var PropTypes = require('prop-types');
var clsx_m = require('../../../clsx/dist/clsx.m.js');
var chainPropTypes = require('../../utils/esm/chainPropTypes.js');
require('../../utils/esm/elementAcceptingRef.js');
require('../../utils/esm/elementTypeAcceptingRef.js');
require('react-is');
require('../../utils/esm/ponyfillGlobal.js');
require('../../utils/esm/refType.js');
require('../../utils/esm/integerPropType.js');
var composeClasses = require('../../utils/esm/composeClasses/composeClasses.js');
var isHostComponent = require('../utils/isHostComponent.js');
var sliderUnstyledClasses = require('./sliderUnstyledClasses.js');
var useSlider = require('./useSlider.js');
var useSlotProps = require('../utils/useSlotProps.js');
var jsxRuntime = require('react/jsx-runtime');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);

const _excluded = ["aria-label", "aria-valuetext", "aria-labelledby", "className", "component", "classes", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "scale", "step", "tabIndex", "track", "value", "valueLabelFormat", "isRtl", "defaultValue", "slotProps", "slots"];
// @ts-ignore
function Identity(x) {
  return x;
}
const useUtilityClasses = ownerState => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', dragging && 'dragging', marked && 'marked', orientation === 'vertical' && 'vertical', track === 'inverted' && 'trackInverted', track === false && 'trackFalse'],
    rail: ['rail'],
    track: ['track'],
    mark: ['mark'],
    markActive: ['markActive'],
    markLabel: ['markLabel'],
    markLabelActive: ['markLabelActive'],
    valueLabel: ['valueLabel'],
    thumb: ['thumb', disabled && 'disabled'],
    active: ['active'],
    disabled: ['disabled'],
    focusVisible: ['focusVisible']
  };
  return composeClasses["default"](slots, sliderUnstyledClasses.getSliderUtilityClass, classes);
};

/**
 *
 * Demos:
 *
 * - [Unstyled Slider](https://mui.com/base/react-slider/)
 *
 * API:
 *
 * - [SliderUnstyled API](https://mui.com/base/api/slider-unstyled/)
 */
const SliderUnstyled = /*#__PURE__*/React__namespace.forwardRef(function SliderUnstyled(props, ref) {
  var _ref, _slots$rail, _slots$track, _slots$thumb, _slots$mark, _slots$markLabel;
  const {
      'aria-label': ariaLabel,
      'aria-valuetext': ariaValuetext,
      'aria-labelledby': ariaLabelledby,
      className,
      component,
      classes: classesProp,
      disableSwap = false,
      disabled = false,
      getAriaLabel,
      getAriaValueText,
      marks: marksProp = false,
      max = 100,
      min = 0,
      orientation = 'horizontal',
      scale = Identity,
      step = 1,
      track = 'normal',
      valueLabelFormat = Identity,
      isRtl = false,
      defaultValue,
      slotProps = {},
      slots = {}
    } = props,
    other = objectWithoutPropertiesLoose["default"](props, _excluded);

  // all props with defaults
  // consider extracting to hook an reusing the lint rule for the variants
  const partialOwnerState = _extends["default"]({}, props, {
    marks: marksProp,
    classes: classesProp,
    disabled,
    isRtl,
    defaultValue,
    max,
    min,
    orientation,
    scale,
    step,
    track,
    valueLabelFormat
  });
  const {
    axisProps,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    active,
    axis,
    range,
    focusedThumbIndex,
    dragging,
    marks,
    values,
    trackOffset,
    trackLeap
  } = useSlider["default"](_extends["default"]({}, partialOwnerState, {
    ref
  }));
  const ownerState = _extends["default"]({}, partialOwnerState, {
    marked: marks.length > 0 && marks.some(mark => mark.label),
    dragging,
    focusedThumbIndex
  });
  const classes = useUtilityClasses(ownerState);
  const Root = (_ref = component != null ? component : slots.root) != null ? _ref : 'span';
  const rootProps = useSlotProps["default"]({
    elementType: Root,
    getSlotProps: getRootProps,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    ownerState,
    className: [classes.root, className]
  });
  const Rail = (_slots$rail = slots.rail) != null ? _slots$rail : 'span';
  const railProps = useSlotProps["default"]({
    elementType: Rail,
    externalSlotProps: slotProps.rail,
    ownerState,
    className: classes.rail
  });
  const Track = (_slots$track = slots.track) != null ? _slots$track : 'span';
  const trackProps = useSlotProps["default"]({
    elementType: Track,
    externalSlotProps: slotProps.track,
    additionalProps: {
      style: _extends["default"]({}, axisProps[axis].offset(trackOffset), axisProps[axis].leap(trackLeap))
    },
    ownerState,
    className: classes.track
  });
  const Thumb = (_slots$thumb = slots.thumb) != null ? _slots$thumb : 'span';
  const thumbProps = useSlotProps["default"]({
    elementType: Thumb,
    getSlotProps: getThumbProps,
    externalSlotProps: slotProps.thumb,
    ownerState
  });
  const ValueLabel = slots.valueLabel;
  const valueLabelProps = useSlotProps["default"]({
    elementType: ValueLabel,
    externalSlotProps: slotProps.valueLabel,
    ownerState
  });
  const Mark = (_slots$mark = slots.mark) != null ? _slots$mark : 'span';
  const markProps = useSlotProps["default"]({
    elementType: Mark,
    externalSlotProps: slotProps.mark,
    ownerState,
    className: classes.mark
  });
  const MarkLabel = (_slots$markLabel = slots.markLabel) != null ? _slots$markLabel : 'span';
  const markLabelProps = useSlotProps["default"]({
    elementType: MarkLabel,
    externalSlotProps: slotProps.markLabel,
    ownerState
  });
  const Input = slots.input || 'input';
  const inputProps = useSlotProps["default"]({
    elementType: Input,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: slotProps.input,
    ownerState
  });
  return /*#__PURE__*/jsxRuntime.jsxs(Root, _extends["default"]({}, rootProps, {
    children: [/*#__PURE__*/jsxRuntime.jsx(Rail, _extends["default"]({}, railProps)), /*#__PURE__*/jsxRuntime.jsx(Track, _extends["default"]({}, trackProps)), marks.filter(mark => mark.value >= min && mark.value <= max).map((mark, index) => {
      const percent = useSlider.valueToPercent(mark.value, min, max);
      const style = axisProps[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values.indexOf(mark.value) !== -1;
      } else {
        markActive = track === 'normal' && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === 'inverted' && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
      }
      return /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx(Mark, _extends["default"]({
          "data-index": index
        }, markProps, !isHostComponent["default"](Mark) && {
          markActive
        }, {
          style: _extends["default"]({}, style, markProps.style),
          className: clsx_m.clsx(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /*#__PURE__*/jsxRuntime.jsx(MarkLabel, _extends["default"]({
          "aria-hidden": true,
          "data-index": index
        }, markLabelProps, !isHostComponent["default"](MarkLabel) && {
          markLabelActive: markActive
        }, {
          style: _extends["default"]({}, style, markLabelProps.style),
          className: clsx_m.clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, index);
    }), values.map((value, index) => {
      const percent = useSlider.valueToPercent(value, min, max);
      const style = axisProps[axis].offset(percent);
      return /*#__PURE__*/jsxRuntime.jsxs(Thumb, _extends["default"]({
        "data-index": index,
        "data-focusvisible": focusedThumbIndex === index
      }, thumbProps, {
        className: clsx_m.clsx(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
        style: _extends["default"]({}, style, {
          pointerEvents: disableSwap && active !== index ? 'none' : undefined
        }, thumbProps.style),
        children: [/*#__PURE__*/jsxRuntime.jsx(Input, _extends["default"]({
          "data-index": index,
          "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
          "aria-valuenow": scale(value),
          "aria-labelledby": ariaLabelledby,
          "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
          value: values[index]
        }, inputProps)), ValueLabel ? /*#__PURE__*/jsxRuntime.jsx(ValueLabel, _extends["default"]({}, !isHostComponent["default"](ValueLabel) && {
          valueLabelFormat,
          index,
          disabled
        }, valueLabelProps, {
          children: typeof valueLabelFormat === 'function' ? valueLabelFormat(scale(value), index) : valueLabelFormat
        })) : null]
      }), index);
    })]
  }));
});
process.env.NODE_ENV !== "production" ? SliderUnstyled.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The label of the slider.
   */
  'aria-label': chainPropTypes["default"](PropTypes__default["default"].string, props => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props['aria-label'] != null) {
      return new Error('MUI: You need to use the `getAriaLabel` prop instead of `aria-label` when using a range slider.');
    }
    return null;
  }),
  /**
   * The id of the element containing a label for the slider.
   */
  'aria-labelledby': PropTypes__default["default"].string,
  /**
   * A string value that provides a user-friendly name for the current value of the slider.
   */
  'aria-valuetext': chainPropTypes["default"](PropTypes__default["default"].string, props => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props['aria-valuetext'] != null) {
      return new Error('MUI: You need to use the `getAriaValueText` prop instead of `aria-valuetext` when using a range slider.');
    }
    return null;
  }),
  /**
   * @ignore
   */
  children: PropTypes__default["default"].node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes__default["default"].object,
  /**
   * @ignore
   */
  className: PropTypes__default["default"].string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes__default["default"].elementType,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].arrayOf(PropTypes__default["default"].number), PropTypes__default["default"].number]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: PropTypes__default["default"].bool,
  /**
   * If `true`, the active thumb doesn't swap when moving pointer over a thumb while dragging another thumb.
   * @default false
   */
  disableSwap: PropTypes__default["default"].bool,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the thumb labels of the slider.
   * This is important for screen reader users.
   * @param {number} index The thumb label's index to format.
   * @returns {string}
   */
  getAriaLabel: PropTypes__default["default"].func,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current value of the slider.
   * This is important for screen reader users.
   * @param {number} value The thumb label's value to format.
   * @param {number} index The thumb label's index to format.
   * @returns {string}
   */
  getAriaValueText: PropTypes__default["default"].func,
  /**
   * If `true` the Slider will be rendered right-to-left (with the lowest value on the right-hand side).
   * @default false
   */
  isRtl: PropTypes__default["default"].bool,
  /**
   * Marks indicate predetermined values to which the user can move the slider.
   * If `true` the marks are spaced according the value of the `step` prop.
   * If an array, it should contain objects with `value` and an optional `label` keys.
   * @default false
   */
  marks: PropTypes__default["default"].oneOfType([PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
    label: PropTypes__default["default"].node,
    value: PropTypes__default["default"].number.isRequired
  })), PropTypes__default["default"].bool]),
  /**
   * The maximum allowed value of the slider.
   * Should not be equal to min.
   * @default 100
   */
  max: PropTypes__default["default"].number,
  /**
   * The minimum allowed value of the slider.
   * Should not be equal to max.
   * @default 0
   */
  min: PropTypes__default["default"].number,
  /**
   * Name attribute of the hidden `input` element.
   */
  name: PropTypes__default["default"].string,
  /**
   * Callback function that is fired when the slider's value changed.
   *
   * @param {Event} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event not a change event.
   * @param {number | number[]} value The new value.
   * @param {number} activeThumb Index of the currently moved thumb.
   */
  onChange: PropTypes__default["default"].func,
  /**
   * Callback function that is fired when the `mouseup` is triggered.
   *
   * @param {React.SyntheticEvent | Event} event The event source of the callback. **Warning**: This is a generic event not a change event.
   * @param {number | number[]} value The new value.
   */
  onChangeCommitted: PropTypes__default["default"].func,
  /**
   * The component orientation.
   * @default 'horizontal'
   */
  orientation: PropTypes__default["default"].oneOf(['horizontal', 'vertical']),
  /**
   * A transformation function, to change the scale of the slider.
   * @param {any} x
   * @returns {any}
   * @default function Identity(x) {
   *   return x;
   * }
   */
  scale: PropTypes__default["default"].func,
  /**
   * The props used for each slot inside the Slider.
   * @default {}
   */
  slotProps: PropTypes__default["default"].shape({
    input: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    mark: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    markLabel: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    rail: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    root: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    thumb: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    track: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    valueLabel: PropTypes__default["default"].oneOfType([PropTypes__default["default"].any, PropTypes__default["default"].func])
  }),
  /**
   * The components used for each slot inside the Slider.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: PropTypes__default["default"].shape({
    input: PropTypes__default["default"].elementType,
    mark: PropTypes__default["default"].elementType,
    markLabel: PropTypes__default["default"].elementType,
    rail: PropTypes__default["default"].elementType,
    root: PropTypes__default["default"].elementType,
    thumb: PropTypes__default["default"].elementType,
    track: PropTypes__default["default"].elementType,
    valueLabel: PropTypes__default["default"].elementType
  }),
  /**
   * The granularity with which the slider can step through values. (A "discrete" slider.)
   * The `min` prop serves as the origin for the valid values.
   * We recommend (max - min) to be evenly divisible by the step.
   *
   * When step is `null`, the thumb can only be slid onto marks provided with the `marks` prop.
   * @default 1
   */
  step: PropTypes__default["default"].number,
  /**
   * Tab index attribute of the hidden `input` element.
   */
  tabIndex: PropTypes__default["default"].number,
  /**
   * The track presentation:
   *
   * - `normal` the track will render a bar representing the slider value.
   * - `inverted` the track will render a bar representing the remaining slider value.
   * - `false` the track will render without a bar.
   * @default 'normal'
   */
  track: PropTypes__default["default"].oneOf(['inverted', 'normal', false]),
  /**
   * The value of the slider.
   * For ranged sliders, provide an array with two values.
   */
  value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].arrayOf(PropTypes__default["default"].number), PropTypes__default["default"].number]),
  /**
   * The format function the value label's value.
   *
   * When a function is provided, it should have the following signature:
   *
   * - {number} value The value label's value to format
   * - {number} index The value label's index to format
   * @param {any} x
   * @returns {any}
   * @default function Identity(x) {
   *   return x;
   * }
   */
  valueLabelFormat: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].string])
} : void 0;

exports["default"] = SliderUnstyled;
//# sourceMappingURL=SliderUnstyled.js.map
