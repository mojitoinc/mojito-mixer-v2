'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('../../../utils/esm/elementAcceptingRef.js');
require('../../../utils/esm/elementTypeAcceptingRef.js');
require('react-is');
require('../../../utils/esm/ponyfillGlobal.js');
require('../../../utils/esm/refType.js');
var capitalize = require('../../../utils/esm/capitalize.js');
require('react');
require('../../../utils/esm/integerPropType.js');
var merge = require('../merge.js');
var style = require('../style.js');
var breakpoints = require('../breakpoints.js');
var defaultSxConfig = require('./defaultSxConfig.js');

function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every(object => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
}

// eslint-disable-next-line @typescript-eslint/naming-convention
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style$1
    } = options;
    if (val == null) {
      return null;
    }
    const themeMapping = style.getPath(theme, themeKey) || {};
    if (style$1) {
      return style$1(props);
    }
    const styleFromPropValue = propValueFinal => {
      let value = style.getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === 'string') {
        // Haven't found value
        value = style.getStyleValue(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize["default"](propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return breakpoints.handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null; // Emotion & styled-components will neglect null
    }

    const config = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig["default"];

    /*
     * Receive `sxInput` as object or callback
     * and then recursively check keys & values to create media query object styles.
     * (the result will be used in `styled`)
     */
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === 'function') {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== 'object') {
        // value
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = breakpoints.createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css = emptyBreakpoints;
      Object.keys(sxObject).forEach(styleKey => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== undefined) {
          if (typeof value === 'object') {
            if (config[styleKey]) {
              css = merge["default"](css, getThemeValue(styleKey, value, theme, config));
            } else {
              const breakpointsValues = breakpoints.handleBreakpoints({
                theme
              }, value, x => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css[styleKey] = styleFunctionSx({
                  sx: value,
                  theme
                });
              } else {
                css = merge["default"](css, breakpointsValues);
              }
            }
          } else {
            css = merge["default"](css, getThemeValue(styleKey, value, theme, config));
          }
        }
      });
      return breakpoints.removeUnusedBreakpoints(breakpointsKeys, css);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ['sx'];

exports["default"] = styleFunctionSx;
exports.unstable_createStyleFunctionSx = unstable_createStyleFunctionSx;
//# sourceMappingURL=styleFunctionSx.js.map
